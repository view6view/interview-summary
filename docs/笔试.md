# 滴滴

## 2022年6月11日

> 判断一个num数组，是否可以划分成两个子序列，一个序列递增，另外一个序列递减

```java
import java.util.Scanner;
import java.util.Stack;

public class Test1 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();
        boolean[] res = new boolean[t];
        for (int i = 0; i < t; i++) {
            int n = scanner.nextInt();
            int[] nums = new int[n];
            for (int j = 0; j < n; j++) {
                nums[j] = scanner.nextInt();
            }
            res[i] = dfs(nums, 0, new Stack<>(), new java.util.Stack<>());
        }
        for (boolean re : res) {
            if (re) {
                System.out.println("OK");
            } else {
                System.out.println("NO");
            }
        }
    }

    public static boolean dfs(int[] nums, int idx, Stack<Integer> up, Stack<Integer> down) {
        if (idx == nums.length) {
            return true;
        }

        if (up.isEmpty() || nums[idx] > up.peek()) {
            up.push(nums[idx]);
            if (dfs(nums, idx + 1, up, down)) {
                return true;
            }
            up.pop();
        }

        if (down.isEmpty() || nums[idx] < down.peek()) {
            down.push(nums[idx]);
            if (dfs(nums, idx + 1, up, down)) {
                return true;
            }
            down.pop();
        }

        return false;
    }
}
```

- 测试用例

```
3
6
3 6 5 1 4 2
7
7 4 1 3 2 5 6
6
1 4 3 6 5 2
```

- 输出结果

```
NO
OK
NO
```

# 排序

## 快速排序

```java
import java.util.Arrays;

public class QuickSort {
    public static void main(String[] args) {
        int[] nums = new int[]{15, 19, 20, 13, 29, 30, 2, 6};
        quickSort(nums, 0 , nums.length - 1);
        System.out.println(Arrays.toString(nums));
    }

    public static void quickSort(int[] nums, int low, int high) {
        if (low < high) {
            int partition = partition(nums, low, high);
            quickSort(nums, low, partition - 1);
            quickSort(nums, partition + 1, high);
        }
    }

    private static int partition(int[] nums, int low, int high) {
        int pivot = nums[high];
        int pointer = low;
        int temp;
        for (int i = low; i < high; i++) {
            if (nums[i] < pivot) {
                temp = nums[i];
                nums[i] = nums[pointer];
                nums[pointer] = temp;
                pointer++;
            }
        }
        temp = nums[high];
        nums[high] = nums[pointer];
        nums[pointer] = temp;
        return pointer;
    }
}
```
