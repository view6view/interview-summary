# 疯狂游戏

## 硬币兑换

兑换硬币所需要的最少硬币数量，a了80

```java
import java.util.Scanner;

public class Test1 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int nextInt = scanner.nextInt();
        int cnt1 = 0, cnt4 = 0, cnt5 = 0;
        while (nextInt >= 5) {
            if (nextInt % 5 == 0) {
                cnt5 += (nextInt / 5);
                nextInt %= 5;
                break;
            }
            if (nextInt % 4 == 0) {
                cnt4 += (nextInt / 4);
                nextInt %= 4;
                break;
            }
            cnt5 ++;
            nextInt -= 5;
        }
        cnt4 += (nextInt / 4);
        nextInt %= 4;
        cnt1 += nextInt;
        System.out.printf("%d,%d,%d", cnt1, cnt4, cnt5);
    }
}
```

## 可以构成指定和的子序列

找到所有的和等于sum的子序列，子序列长度小的排在前面，长度相等的，按照子序列的每位数升序排列

```java
import java.util.*;
import java.util.stream.Collectors;

public class Test2 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String[] nextLine = scanner.nextLine().split(";");
        List<Integer> nums = Arrays.stream(nextLine[0].split(",")).map(Integer::valueOf).sorted().collect(Collectors.toList());
        int sum = Integer.parseInt(nextLine[1]);
        List<List<Integer>> lists = calc(nums, sum);
        for (int i = 0; i < lists.size() - 1; i++) {
            List<Integer> list = lists.get(i);
            for (int j = 0; j < list.size() - 1; j++) {
                System.out.printf("%d,", list.get(j));
            }
            System.out.printf("%d;", list.get(list.size() - 1));
        }
        List<Integer> list = lists.get(lists.size() - 1);
        for (int j = 0; j < list.size() - 1; j++) {
            System.out.printf("%d,", list.get(j));
        }
        System.out.printf("%d", list.get(list.size() - 1));
    }

    public static List<List<Integer>> calc(List<Integer> nums, int sum) {
        List<List<Integer>> res = new LinkedList<>();
        for (int i = nums.size() - 1; i >= 0; i--) {
            List<List<Integer>> need = need(nums, i, sum - nums.get(i));
            if (need != null) {
                if (need.size() == 0) {
                    ArrayList<Integer> list = new ArrayList<>(1);
                    list.add(nums.get(i));
                    res.add(list);
                } else {
                    for (List<Integer> list : need) {
                        list.add(nums.get(i));
                        Collections.sort(list);
                        res.add(list);
                    }
                }
            }
        }
        res.sort(new Comparator<List<Integer>>() {
            @Override
            public int compare(List<Integer> o1, List<Integer> o2) {
                int flag = o1.size() - o2.size();
                if (flag != 0) {
                    return flag;
                }
                int size = o1.size();
                for (int i = 0; i < size; i++) {
                    if (!o1.get(i).equals(o2.get(i))) {
                        return o1.get(i).compareTo(o2.get(i));
                    }
                }
                return 0;
            }
        });
        return res;
    }

    private static List<List<Integer>> need(List<Integer> nums, int idx, int need) {
        if (need < 0 || (need > 0 && idx == 0) ) {
            return null;
        }
        List<List<Integer>> res = new LinkedList<>();
        if (need == 0) {
            return res;
        }
        for (int i = idx - 1; i >= 0; i--) {
            List<List<Integer>> dfs = need(nums, i, need - nums.get(i));
            if (dfs != null) {
                if (dfs.size() == 0) {
                    ArrayList<Integer> list = new ArrayList<>(1);
                    list.add(nums.get(i));
                    res.add(list);
                } else {
                    for (List<Integer> df : dfs) {
                        df.add(nums.get(i));
                        res.add(df);
                    }
                }
            }
        }
        if (res.size() == 0) {
            return null;
        }
        return res;
    }
}
```

# 墨奇科技

## 两个整数反转求和

题目要求：

![image-20220725103010918](images/image-20220725103010918.png)

![image-20220725103021505](images/image-20220725103021505.png)

代码实现：

```java
public int adding_reverse_num (int num1, int num2) {
    // write code here
    Queue<Integer> queue = new LinkedList<>();
    num1 = reverse(queue, num1);
    num2 = reverse(queue, num2);
    return reverse(queue, num1 + num2);
}

private int reverse(Queue<Integer> queue, int num) {
    while (num > 0) {
        queue.add(num % 10);
        num /= 10;
    }
    num = 0;
    while (!queue.isEmpty() && queue.peek().equals(0)) {
        queue.poll();
    }
    while (!queue.isEmpty()) {
        num = num * 10 + queue.poll();
    }
    return num;
}
```

## 简易RSA，通过公钥进行解密

题目要求：

![image-20220725103712269](images/image-20220725103712269.png)

![image-20220725103729093](images/image-20220725103729093.png)

代码实现：

```java
public int decodeRSA(int[] pub_key, int c) {
    // write code here
    // 通过公钥推导私钥
    int n = pub_key[0], e = pub_key[1];
    int p = 0, q = 0;
    for (int i = 2; i <= n / 2; i++) {
        if (n % i == 0 && isPrime(i) && isPrime(n / i)) {
            p = i;
            q = n / i;
            break;
        }
    }
    int epq = (p - 1) * (q - 1);
    int d = 2;
    while ((e * d) % epq != 1) {
        d++;
    }
    return decode(c, n, d);
}

/**
 * 通过私钥解密
 * @param c
 * @param n
 * @param d
 * @return
 */
private int decode(int c, int n, int d) {
    int res = c % n;
    for (int i = 1; i < d; i++) {
        res = (res * c) % n;
    }
    return res;
}

/**
 * 判断是否为素数
 * @param n
 * @return
 */
public boolean isPrime(int n) {
    if (n < 2) return false;
    if (n == 2) return true;
    if (n % 2 == 0) return false;
    for (int i = 3; i * i <= n; i+=2) {
        if (n % i == 0) return false;
    }
    return true;
}
```

# 滴滴

## 2022年6月11日

> 判断一个num数组，是否可以划分成两个子序列，一个序列递增，另外一个序列递减

```java
import java.util.Scanner;
import java.util.Stack;

public class Test1 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();
        boolean[] res = new boolean[t];
        for (int i = 0; i < t; i++) {
            int n = scanner.nextInt();
            int[] nums = new int[n];
            for (int j = 0; j < n; j++) {
                nums[j] = scanner.nextInt();
            }
            res[i] = dfs(nums, 0, new Stack<>(), new java.util.Stack<>());
        }
        for (boolean re : res) {
            if (re) {
                System.out.println("OK");
            } else {
                System.out.println("NO");
            }
        }
    }

    public static boolean dfs(int[] nums, int idx, Stack<Integer> up, Stack<Integer> down) {
        if (idx == nums.length) {
            return true;
        }

        if (up.isEmpty() || nums[idx] > up.peek()) {
            up.push(nums[idx]);
            if (dfs(nums, idx + 1, up, down)) {
                return true;
            }
            up.pop();
        }

        if (down.isEmpty() || nums[idx] < down.peek()) {
            down.push(nums[idx]);
            if (dfs(nums, idx + 1, up, down)) {
                return true;
            }
            down.pop();
        }

        return false;
    }
}
```

- 测试用例

```
3
6
3 6 5 1 4 2
7
7 4 1 3 2 5 6
6
1 4 3 6 5 2
```

- 输出结果

```
NO
OK
NO
```

## 二维递增数组，如何查询第k小的数

二维数组的规律，没行从左到右依次递增，每列从上到下依次递增，查找出第k小的数

思路：

通过一个优先队列和一个visited数组，去遍历节点

代码实现：

```java
import java.util.Comparator;
import java.util.PriorityQueue;

public class Test2 {
    public static void main(String[] args) {
        int[][] arr = new int[][]{
                {1,3,7},
                {2,5,8},
                {4,6,9}
        };
        System.out.println(findK(arr, 9));
    }

    public static int findK(int[][] arr, int k) {
        int height = arr.length;
        int weight = arr[0].length;
        if (k > height*weight) {
            return -1;
        }
        PriorityQueue<int[]> priorityQueue = new PriorityQueue<>(new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                return o1[0] - o2[0];
            }
        });
        priorityQueue.add(new int[]{arr[0][0], 0, 0});
        boolean[][] visited = new boolean[height][weight];
        visited[0][0] = true;
        while (--k > 0) {
            int[] poll = priorityQueue.poll();
            int x = poll[1];
            int y = poll[2];
            int right = x + 1;
            int under = y + 1;
            if (right < weight && !visited[y][right]) {
                visited[y][right] = true;
                priorityQueue.add(new int[]{arr[y][right], y, right});
            }
            if (under < height && !visited[under][x]) {
                visited[under][x] = true;
                priorityQueue.add(new int[]{arr[under][x], under, x});
            }
        }
        return priorityQueue.poll()[0];
    }
}
```

# 蔚来

## n个数字中二进制1的个数

```java
public int count(int[] arr) {
    int res = 0;
    for (int i : arr) {
        int cur = 0;
        while (i != 0) {
            cur += i & 1;
            i >>>= 1;
        }
        res += cur;
    }
    return res;
}
```

## 删除链表倒数第n个节点

```java
class Node {
    private int val;
    private Node next;

    public Node(int val) {
        this.val = val;
    }
}

public Node deleteK(Node head, int k) {
    Node originHead = new Node(0);
    originHead.next = head;
    Node pre = originHead;
    Node slow = pre.next;
    Node fast = pre.next;
    while (k > 0) {
        if (fast.next == null) {
            return head;
        }
        fast = fast.next;
        k--;
    }
    
    while (fast.next != null) {
        pre = slow;
        slow = slow.next;
        fast = fast.next;
    }
    pre.next = slow.next;
    return originHead.next;
}
```

## 复原ip地址

```java
public List<String> restoreIpAddresses(String s) {
    List<String> res = new LinkedList<>();
    Deque<String> path = new LinkedList<>();
    dfs(0, 4, path, res, s, s.length());
    return res;
}

private void dfs(int begin, int split, Deque<String> path, List<String> res, String s, int len) {
    if (begin == len) {
        if (split == 0) {
            res.add(String.join(".", path));
        }
        return;
    }

    for (int i = begin + 1; i <= begin + 3; i++) {
        // i 超过 s 的长度时候，跳出循环
        if (i > len) {
            break;
        }
        // 当剩余的长度大于最大可划分ip数时，continue
        if (split * 3 < len - i + 1) {
            continue;
        }
        String substring = s.substring(begin, i);
        if (valid(substring)) {
            path.addLast(substring);
            dfs(i, split - 1, path, res, s, len);
            path.removeLast();
        }
    }
}

private boolean valid(String s) {
    if (s.charAt(0) == '0' && s.length() > 1) {
        return false;
    }
    int ip = Integer.parseInt(s);
    return ip > -1 && ip < 256;
}
```

## 前序和中序遍历结果还原二叉树

```java
import java.util.Stack;

public class Test5 {
    class TreeNode {
        int val;

        TreeNode left;

        TreeNode right;

        TreeNode(int val) {
            this.val = val;
        }
    }

    /**
     *         3
     *        / \
     *       9  20
     *      /  /  \
     *     8  15   7
     *    / \
     *   5  10
     *  /
     * 4
     * preorder = [3, 9, 8, 5, 4, 10, 20, 15, 7]
     * inorder = [4, 5, 8, 10, 9, 3, 15, 20, 7]
     * 入栈顺序: 3,9,8,5,4 -> 3,9 -> 3,9,10 ->  _ -> 20 -> 20,15 -> _ -> 7
     *
     * @param preorder
     * @param inorder
     * @return
     */
    /**
     * @see <a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">leetcode</a>
     */
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        if (preorder == null || preorder.length == 0) {
            return null;
        }
        TreeNode root = new TreeNode(preorder[0]);
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        int inorderIdx = 0;
        for (int i = 1; i < preorder.length; i++) {
            TreeNode node = stack.peek();
            // 说明当前节点为栈顶的左子节点
            if (node.val != inorder[inorderIdx]) {
                node.left = new TreeNode(preorder[i]);
                stack.push(node.left);
            } else {
                // 如果都没有右子节点，那么依次弹出栈顶节点应该和inorderIdx节点遍历的值一样
                // 当不一样了，说明当前preorder[i]为前一个弹出栈顶节点的右子节点
                while (!stack.isEmpty() && stack.peek().val == inorder[inorderIdx]) {
                    node = stack.pop();
                    inorderIdx++;
                }
                node.right = new TreeNode(preorder[i]);
                stack.push(node.right);
            }
        }
        return root;
    }
}
```

大佬解法

```java
public class Test5 {
    class TreeNode {
        int val;

        TreeNode left;

        TreeNode right;

        TreeNode(int val) {
            this.val = val;
        }
    }

    private int in = 0;
    private int pre = 0;
    
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        return build(preorder, inorder, Integer.MIN_VALUE);
    }

    private TreeNode build(int[] preorder, int[] inorder, int stop) {
        // pre走到preorder末尾
        if (pre == preorder.length) return null;
        // in指针走到了停止点
        if (inorder[in] == stop) {
            // stop点废弃了，in推进一位
            in++;
            return null;
        }
        TreeNode node = new TreeNode(preorder[pre]);
        pre++;
        // 左子树的停止点是当前的根节点的值
        node.left = build(preorder, inorder, node.val);
        // 右子树的停止点是当前树的停止点
        node.right = build(preorder, inorder, stop);
        return node;
    }
}
```

## 前序和后序遍历构造二叉树

```java
int preIndex = 0, posIndex = 0;

/**
 * @see <a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">leetcode</a>
 */
public TreeNode constructFromPrePost(int[] pre, int[] post) {
    TreeNode root = new TreeNode(pre[preIndex++]);
    if (root.val != post[posIndex])
        root.left = constructFromPrePost(pre, post);
    if (root.val != post[posIndex])
        root.right = constructFromPrePost(pre, post);
    posIndex++;
    return root;
}
```

## 前序遍历构造二叉搜索树

```java
/**
 * @see <a href="https://leetcode.cn/problems/construct-binary-search-tree-from-preorder-traversal/">leetcode</a>
 */
public TreeNode bstFromPreorder(int[] preorder) {
    if (preorder.length == 0) return null;
    TreeNode root = new TreeNode(preorder[0]);
    for (int i = 1; i < preorder.length; i++) {
        insert(root, preorder[i]);
    }
    return root;
}

/**
 * 插入节点
 *
 * @param root 二叉树根节点
 * @param val  插入的值
 */
private void insert(TreeNode root, int val) {
    if (root.val > val) { // 如果根节点大于插入的值，则插入到左子树
        if (root.left == null) {
            root.left = new TreeNode(val);
        } else {
            // 如果左子树不为空，则递归插入
            insert(root.left, val);
        }
    } else { // 如果根节点小于插入的值，则插入到右子树
        if (root.right == null) {
            root.right = new TreeNode(val);
        } else {
            // 如果右子树不为空，则递归插入
            insert(root.right, val);
        }
    }
}
```

## 编辑距离

```java
/**
 * @see <a href="https://leetcode.cn/problems/edit-distance/">leetcode</a>
 */
public int minDistance(String word1, String word2) {
    int m = word1.length();
    int n = word2.length();
    if (m == 0) {
        return n;
    }
    if (n == 0) {
        return m;
    }

    int[][] dp = new int[m + 1][n + 1];

    // 分别定义边界，dp[m][0] 表示 word2从: 空字符串 ——> word1 需要多少距离
    for (int i = 1; i <= m; i++) {
        dp[i][0] = i;
    }
    for (int i = 1; i <= n; i++) {
        dp[0][i] = i;
    }

    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            // 删除当前字符
            int left = dp[i][j - 1] + 1;
            // 添加当前字符
            int down = dp[i - 1][j] + 1;
            // 替换字符
            int left_down = dp[i - 1][j - 1];
            if (word1.charAt(i - 1) != word2.charAt(j - 1)) {
                left_down++;
            }
            dp[i][j] = Math.min(Math.min(left, down), left_down);
        }
    }
    return dp[m][n];
}
```

## 找到最底部左边的节点

```java
/**
 * @see <a href="https://leetcode.cn/problems/LwUNpT/">leetcode</a>
 */
public int findBottomLeftValue(TreeNode root) {
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root);
    int res = 0;
    while (!queue.isEmpty()) {
        int size = queue.size();
        TreeNode node = queue.poll();
        res = node.val;
        if (node.left != null) {
            queue.add(node.left);
        }
        if (node.right != null) {
            queue.add(node.right);
        }
        for (int i = 1; i < size; i++) {
            node = queue.poll();
            if (node.left != null) {
                queue.add(node.left);
            }
            if (node.right != null) {
                queue.add(node.right);
            }
        }
    }
    return res;
}
```

# 字节

## 旋转数组找最小值

无重复，leetcode153

```java
public int findMin(int[] nums) {
    int left = 0, right = nums.length - 1;
    while (left < right) {
        int mid = (left + right) / 2;
        if (nums[mid] > nums[right]) left = mid + 1;
        else right = mid;
    }
    return nums[left];
}
```

可重复，leetcode154

```java
public int findMin(int[] nums) {
    int left = 0, right = nums.length - 1;
    while (left < right) {
        int mid = (left + right) / 2;
        if (nums[mid] > nums[right]) left = mid + 1;
        else if (nums[mid] < nums[right]) right = mid;
        // 原因是此题中数组的元素可重复，难以判断分界点 ii 指针区间）
        // 例如 [1, 0, 1, 1, 1] 和 [1, 1, 1, 0, 1] ，
        // 在 left = 0, right = 4, mid = 2 时，无法判断 mid 在哪个排序数组中。
        // right = right - 1 解决此问题
        else right--;
    }
    return nums[left];
}
```

# 排序

## 快速排序

```java
import java.util.Arrays;

public class QuickSort {
    public static void main(String[] args) {
        int[] nums = new int[]{15, 19, 20, 13, 29, 30, 2, 6};
        quickSort(nums, 0 , nums.length - 1);
        System.out.println(Arrays.toString(nums));
    }

    public static void quickSort(int[] nums, int low, int high) {
        if (low < high) {
            int partition = partition(nums, low, high);
            quickSort(nums, low, partition - 1);
            quickSort(nums, partition + 1, high);
        }
    }

    private static int partition(int[] nums, int low, int high) {
        int pivot = nums[high];
        int pointer = low;
        int temp;
        for (int i = low; i < high; i++) {
            if (nums[i] < pivot) {
                temp = nums[i];
                nums[i] = nums[pointer];
                nums[pointer] = temp;
                pointer++;
            }
        }
        temp = nums[high];
        nums[high] = nums[pointer];
        nums[pointer] = temp;
        return pointer;
    }
}
```

## 堆排序

```java
import java.util.Arrays;

public class HeapSort {
    public static void main(String[] args) {
        int[] array = {91, 60, 96, 13, 35, 65, 46, 65, 10, 30, 20, 31, 77, 81, 22};
        System.out.println("排序前：" + Arrays.toString(array));
        heapSort(array);
        System.out.println("排序前：" + Arrays.toString(array));
    }

    /**
     * 堆排序1,从小到大
     * @param array
     */
    public static void heapSort(int[] array) {
        // 构建大顶堆
        for (int i = array.length/2 - 1; i >= 0; i--) {
            // 从第一个非叶子节点从下到上，从右至左调整结构
            siftDown(array, i, (i + 1) * 2);
        }
        // 调整堆结构，交换堆顶元素与末尾元素
        for (int i = array.length - 1; i > 0; i--) {
            // 将堆顶元素与末尾元素进行交换
            swap(array, 0, i);
            // 重新对堆进行调整
            siftDown(array, 0, i);
        }
    }

    /**
     * 将以 i 对应的非叶子节点的树调整为大顶堆
     * @param array
     * @param i
     * @param length
     */
    public static void siftDown(int[] array, int i, int length) {
        // 取出当前元素i
        int temp = array[i];
        // 从i节点的左子节点开始，也就是2*i+1处开始
        for (int j = i*2 + 1; j < length; j = j*2 + 1) {
            // 如果左子节点小于右子节点，j指向右子节点，因为需要构建大顶堆
            if (j + 1 < length && array[j] < array[j + 1]) {
                j++;
            }
            // 如果子节点大于父节点，将子节点的值赋值父节点，不用交换
            if (array[j] > temp) {
                array[i] = array[j];
                i = j;
            } else {
                break;
            }
        }
        array[i] = temp;
    }

    /**
     * 交换元素
     * @param array
     * @param a
     * @param b
     */
    public static void swap(int []array,int a ,int b){
        int temp=array[a];
        array[a] = array[b];
        array[b] = temp;
    }
}
```

# 字节跳动青训营

## 座位移除

![image-20220718112230835](images/image-20220718112230835.png)

只过了20，不知道哪里出错了

```java
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String[] split = scanner.nextLine().split(" ");
        int n = Integer.valueOf(split[0]), m = Integer.valueOf(split[1]);
        List<Integer> distances = new ArrayList<>(n - 1);
        for (int i = 0; i < n - 1; i++) {
            distances.add(Integer.valueOf(scanner.nextLine()));
        }
        while (m > 0) {
            int minIdx = 0;
            int min = distances.get(minIdx);
            for (int i = 1; i < distances.size(); i++) {
                if (distances.get(i) < min) {
                    minIdx = i;
                    min = distances.get(i);
                }
            }
            if (minIdx > 0 && minIdx < distances.size() - 1) {
                if (distances.get(minIdx - 1) >= distances.get(minIdx + 1)) {
                    distances.remove(minIdx);
                    distances.set(minIdx, distances.get(minIdx) + min);
                } else {
                    distances.remove(minIdx);
                    distances.set(minIdx - 1, distances.get(minIdx - 1) + min);
                }
            } else {
                if (minIdx == 0) {
                    distances.remove(minIdx);
                    distances.set(minIdx, distances.get(minIdx) + min);
                } else {
                    distances.remove(minIdx);
                    distances.set(minIdx - 1, distances.get(minIdx - 1) + min);
                }
            }
            m--;
        }
        int min = Integer.MAX_VALUE;
        for (Integer distance : distances) {
            min = Math.min(min, distance);
        }
        System.out.println(min);
    }
}
```

二分 + 贪心，a'c

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String[] split = scanner.nextLine().split(" ");
        int n = Integer.parseInt(split[0]), m = Integer.parseInt(split[1]);
        int[] arr = new int[n - 1];
        int sum = 0;
        for (int i = 0; i < n - 1; i++) {
            arr[i] = Integer.parseInt(scanner.nextLine());
            sum += arr[i];
        }

        int l = 0, r = sum;
        while (l <= r) {
            int mid = (l + r) >> 1;
            if (validate(mid, m, arr)) l = mid + 1;
            else r = mid - 1;
        }
        System.out.println(r);
    }

    public static boolean validate(int ans, int m, int[] arr) {
        int space = 0;
        for (int i = 0; i < arr.length; i++) {
            space += arr[i];
            // 如果 space >= ans了，则将space置为0，并且不需要移除行
            if (space >= ans) {
                space = 0;
            }
            // 如果 space < ans 则需要移除行实现
            else if (--m < 0) return false;
        }
        return true;
    }
}
```

## 最长消息序列长度

![image-20220718112606375](images/image-20220718112606375.png)

![image-20220718112620721](images/image-20220718112620721.png)

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = Integer.parseInt(scanner.nextLine());
        List<Message> list = new ArrayList<>(n);
        while (n > 0) {
            Message message = new Message(scanner.nextLine());
            list.add(message);
            n--;
        }
        Collections.sort(list);
        int max = 0;
        for (int i = 0; i < list.size() - 1; i++) {
            int curMax = maxLen(list, list.get(i).s, i + 1) + 1;
            max = Math.max(max, curMax);
        }
        System.out.println(max);
    }

    public static int maxLen(List<Message> list, String need, int idx) {
        while (idx < list.size() && !list.get(idx).r.equals(need)) {
            idx++;
        }
        int max = 0;
        while (idx < list.size() && list.get(idx).r.equals(need)) {
            int curMax = maxLen(list, list.get(idx).s, idx + 1) + 1;
            max = Math.max(max, curMax);
            idx++;
        }
        return max;
    }

    static class Message implements Comparable<Message> {
        String r;
        String s;

        public Message(String str) {
            String[] split = str.substring(1, str.length() - 1).split(",");
            this.r = split[3];
            this.s = split[4];
        }

        @Override
        public int compareTo(Message o) {
            if (r.equals(o.r)) {
                return s.compareTo(o.s);
            }
            return r.compareTo(o.r);
        }
    }
}
```

# 常见

## LRU缓存

```java
import java.util.HashMap;
import java.util.Map;

public class LRUCache<K, V> {
    private class Node {
        K k;
        V v;
        Node pre, next;

        public Node(K k, V v) {
            this.k = k;
            this.v = v;
        }
    }

    private int size, capacity;

    private Map<K, Node> cache;

    private Node head, tail;

    public LRUCache(int capacity) {
        this.capacity = capacity;
        size = 0;
        head = new Node(null, null);
        tail = new Node(null, null);
        head.next = tail;
        tail.pre = head;
        cache = new HashMap<>(capacity);
    }

    public void put(K k, V v) {
        Node node = cache.get(k);
        if (node != null) {
            node.v = v;
            moveToHead(node);
        } else {
            node = new Node(k, v);
            addToHead(node);
        }
    }

    public V get(K k) {
        Node node = cache.get(k);
        if (node != null) {
            moveToHead(node);
            return node.v;
        }
        return null;
    }

    public void delete(K k) {
        Node node = cache.get(k);
        if (node != null) {
            removeNode(node);
        }
    }

    private void addToHead(Node node) {
        node.pre = head;
        node.next = head.next;
        head.next.pre = node;
        head.next = node;
        cache.put(node.k, node);
        if (++size > capacity) {
            removeTail();
        }
    }

    private void removeNode(Node node) {
        node.pre.next = node.next;
        node.next.pre = node.pre;
        cache.remove(node.k);
        size--;
    }

    private void moveToHead(Node node) {
        removeNode(node);
        addToHead(node);
    }

    private void removeTail() {
        removeNode(tail.pre);
    }
}
```

## 单例模式

```java
public class SingleTonDemo {

    private static SingleTonDemo instance;

    enum SingleTon {
        INSTANCE;

        public SingleTonDemo getInstance() {
            return new SingleTonDemo();
        }
    }

    public SingleTonDemo getInstance1() {
        return SingleTon.INSTANCE.getInstance();
    }

    public SingleTonDemo getInstance2() {
        if (instance == null) {
            synchronized (SingleTonDemo.class) {
                if (instance == null) {
                    instance = new SingleTonDemo();
                }
            }
        }
        return instance;
    }

    private static class Holder {
        public static SingleTonDemo instance = new SingleTonDemo();
    }

    public SingleTonDemo getInstance3() {
        return Holder.instance;
    }
}
```

## 接雨水

```java
/**
 * @see <a href="https://leetcode-cn.com/problems/trapping-rain-water/">leetcode</a>
 */
public int trap(int[] height) {
    int sum = 0;
    int[] max_left = new int[height.length];
    int[] max_right = new int[height.length];

    // 从右开始遍历，获取每个位置左边最高墙
    for (int i = 1; i < height.length - 1; i++) {
        max_left[i] = Math.max(max_left[i - 1], height[i - 1]);
    }
    // 从左开始遍历，获取每个位置右边最高墙
    for (int i = height.length - 2; i >= 0; i--) {
        max_right[i] = Math.max(max_right[i + 1], height[i + 1]);
    }

    // 遍历每个位置
    for (int i = 1; i < height.length - 1; i++) {
        // 判断min 为 左右两边高墙中较低的
        int min = Math.min(max_left[i], max_right[i]);
        // 判断min是否比当前height[i]高
        if (min > height[i]) {
            // 当前位置可以接的雨水为min - height[i]
            sum = sum + (min - height[i]);
        }
    }
    return sum;
}
```

## 最小栈

```java
import java.util.Stack;

public class MinStack {
    private Stack<Integer> stack;
    private Stack<Integer> minStack;

    public MinStack() {
        stack = new Stack<>();
        minStack = new Stack<>();
    }

    public void push(int val) {
        stack.push(val);
        if (minStack.isEmpty() || val <= minStack.peek()) {
            minStack.push(val);
        }
    }

    public Integer pop() {
        if (stack.isEmpty()) {
            return null;
        }
        Integer pop = stack.pop();
        if (!minStack.isEmpty()) {
            if (pop.equals(minStack.peek())) {
                minStack.pop();
            }
        }
        return pop;
    }

    public Integer top() {
        return stack.isEmpty() ? null : stack.peek();
    }

    public Integer getMin() {
        return minStack.isEmpty() ? null : minStack.peek();
    }
}
```

## 无序数组查找第K大的数

```java
import java.util.Random;

public class Test {

    private static Random rand = new Random();

    public static void main(String[] args) {
        // 无序数组，待查找
        int[] arr = {30, 60, 80, 40, 300, 250, 110, 255, 257, 256, 280, 45, 200, 50};
        // 有序数组，用于对照
        int[] arr1 = {30, 40, 45, 50, 60, 80, 110, 200, 250, 255, 256, 257, 280, 300};
        //测试对整个数组的的查找结果
        for (int i = 1; i < arr.length + 1; ++i) {
            int r = findK(arr, 0, arr.length - 1, i);
            System.out.print(r + " ");
        }
    }

    /**
     * 主元素随机选取的划分
     *
     * @param arr:待处理数组
     * @param l:数组的左边界
     * @param r:数组的右边界
     * @return:此次选取的主元素一趟排序后的最终下标
     */
    private static int randomizedPartition(int[] arr, int l, int r) {
        // 产生的随机数范围是[p, r-1];
        int pivot = rand.nextInt(r - l + 1) + l;
        // 随机产生的元素设为主元素
        int x = arr[pivot];
        int i = l, j = r;
        while (true) {
            while (arr[i] < x)
                i++;
            while (arr[j] > x)
                j--;
            if (i < j) {
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            } else {
                return j;
            }
        }
    }

    /**
     * 非随机划分
     *
     * @param arr:待处理数组
     * @param l:数组的左边界
     * @param r:数组的右边界
     * @return:此次选取的主元素一趟排序后的最终下标
     */
    private static int partition(int[] arr, int l, int r) {
        int pivot = arr[r];
        int pointer = l;
        int temp;
        for (int i = l; i < r; i++) {
            if (arr[i] < pivot) {
                temp = arr[i];
                arr[i] = arr[pointer];
                arr[pointer] = temp;
                pointer++;
            }
        }
        arr[r] = arr[pointer];
        arr[pointer] = pivot;
        return pointer;
    }


    public static int findK(int[] arr, int l, int r, int k) {
        if (l == r)
            return arr[l];
        // 随机选取主元素进行划分
        // int partition = randomizedPartition(arr, l, r);
        // 固定每次选择最左边的元素作为主元素进行划分
        int partition = partition(arr, l, r);
        if ((partition + 1) == k) return arr[partition];
        else if ((partition + 1) < k) return findK(arr, partition + 1, r, k);
        else return findK(arr, l, partition - 1, k);
    }
}
```

## 搜索二维矩阵 II

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        // Z 字形搜索，从右上角开始，递减向左，递增向下
        int m = matrix.length, n = matrix[0].length;
        int i = 0, j = n - 1;
        while (i < m && j >= 0) {
            if (matrix[i][j] == target) {
                return true;
            } else if (matrix[i][j] > target) {
                --j;
            } else {
                ++i;
            }
        }
        return false;
    }
}
```

